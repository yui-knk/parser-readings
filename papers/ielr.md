# IELR(1): Practical LR(1) Parser Tables for Non-LR(1) Grammars with Conflict Resolution

http://web.archive.org/web/20121222063812if_/http://people.cs.clemson.edu:80/~malloy/papers/sac08/paper.pdf

## 1. INTRODUCTION


## 2. MOTIVATING EXAMPLE

> We introduce the term isocores to describe states that have the same core.

"state 1とstate 2はisocores"のように使う。

## 3. METHODOLOGY

### 3.1 Phase 0: LALR(1)

Pager’s algorithmがmysterious conflictsをさけるように状態をmergeしていくのにたいして、IELRは一度LALRを作ってそこからmysterious conflictsを解消していく。

### 3.2 Phase 1: Compute Auxiliary Tables

追加で3つのtableをつくる

* follow_kernel_items
* always_follows
* predecessors

### 3.3 Phase 2: Compute Annotations

問題を引き起こしているstateをmarkする。

### 3.4 Phase 3: Split States

annotaionを考慮しながらLR(0)を再計算する。

### 3.5 Phase 4: Compute Reduction Lookaheads

LA setを再計算する。

### 3.6 Phase 5: Resolve Remaining Conflicts

# The IELR(1) algorithm for generating minimal LR(1) parser tables for non-LR(1) grammars with conflict resolution

https://www.sciencedirect.com/science/article/pii/S0167642309001191

## 1. Introduction

## 2. Formal IELR(1) foundation

### 2.2. Context-free

#### Definition 2.1 (Context-Free Grammar)

G = (V, T, P, S)

V: Variables. 非終端記号
T: Tokens. 終端記号
P: Productions. 生成規則
S: Start symbol. 開始記号

#### Definition 2.2 (Parse Trees)

T(G)

parse trees generated by G

#### Definition 2.5 (LR(1) Parser Specification, Informal)

An LR(1) parser specification: (G, ∆)

∆(U+2206 INCREMENT)はGの全ての状態に対して常に1つのactionを定める関数。
これは例えばBisonであればprecedenceやassociativityといったuserが指定するものと、S/RはSで解決するなどのparser generatorの挙動によるものからなる。

∆を意識したparse treeをT(G, ∆)、言語をL(G, ∆)と表記する。

#### Definition 2.7 (Augmented Context-Free Grammar)

筆記体のGを用いる.
G(G). CFG Gに対して開始状態やEOI tokenを足したもの。

#### Definition 2.8 (LR(1) Item)

LR(1) item (p, d, K, (at, ap, as))

p: Production. つまりルール
d: Dot
K: lookahead set

dは1始まり. 1 <= d <= |ルールの右辺|

#### Definition 2.9 (LR(1) Action)

at: Action Type. "S"はshift, "G"はgoto, "R"はreduce.
ap: Action Production. Reduceに使用するRule. "R"以外のときはundefined
as: Action State. action実行後の遷移先のstate. "R"のときはundefined

#### Definition 2.11 (Canonical LR(1) Parser)

筆記体のCを用いる.
C(G). CFG Gに対するcanonical LR(1)のstateの集合.

#### Definition 2.12 (Isocore Relation)

=の上に○を乗せた記号.

p: Production. つまりルール
d: Dot
が等しいLR(1) itemを表す.

#### Definition 2.13 (Isocore Set)

筆記体のIを用いる.
LR(1) states Σ, LR(1) state sについてsとIsocore Relationなstateを集めたもの.

関数δ(s, y) = s' は state s,s'とsymbol yについて、sのときにyによるs'へのtransitionがあるときにtrueとなる. yはsymbolなので終端,非終端の両方の可能性がある.

例えばstate 4からAでstate 6へ、aでstate 11へ移動するとき、state 4はstate 6や11のpredecessor、state 6や11はstate 4のsuccessorsと呼ぶ.

* state 4 (predecessor) -> state  6 (successors)
* state 4 (predecessor) -> state 11 (successors)

#### Definition 2.14 (Accessing Symbol)

†(ダガー)を用いる.
state sに遷移するために使用したsymbolを表す.

†(state 3) = †(S -> a • Aa) = a

開始状態であることとAccessing Symbolをもたないことは同値.

#### Definition 2.15 (Lanes)

筆記体のLを用いる.
states Σ, state sとしたときLanes L(s, Σ)はsの列の集合であり、sの列をλとしたとき

* λ[1] (λの最初の要素)は開始状態
* λ[|λ|] (λの最後の要素)はs
* λの前後の要素は1回の遷移関係をもつ

開始状態から状態sへの状態の遷移を1つずつ書いたもの(おそらく最短の列という条件は入っていない).

#### Definition 2.16 (Viable Prefixes)

筆記体のVを用いる.
states Σ, state sとしたとき開始状態s'から0回以上の遷移でsに至るときのsymbolの集合.

#### Definition 2.17 (LR(1) Conflict Contributions)

Γを用いる.
state s, token tとして、Γ(t, s)は組(at, ap)の集合で、sのときにtでshiftもしくはreduceするもの.
state s, token tのときにどのような挙動をするか、shiftするか、reduceするか、reduceするのであればどのruleでreduceするかという候補を返す関数。

#### Definition 2.18 (LR(1) Conflict)

|Γ(t, s)| >= 2 のときのこと.

#### Definition 2.19 (Dominant Contribution Function)

∆を用いる.
states Σとしたとき、|Γ(t, s)| >= 1となる全てのsとtにたいして、Γ(t, s)から唯一の要素を決定する関数が∆.

### 2.5. LALR(1) conflicts reconsidered

#### Definition 2.23 (LALR(1) Parser)

筆記体のAを用いる.
Definition 2.8およびDefinition 2.9を参照。

CFG Gについて、A(G)はLALR(1)用にstateをmergeしたものを表す.

#### 2.5.1. Mysterious new conflicts

canonical LR(1)からLALR(1)に変換することで新規に発生したconflicts.
Ahoらがドラゴンブックに書いたとおり、これは必ずR/RでありR/Sは新規には発生しない。

* 注: shiftの状態をmergeしてもshiftするだけなので.

Table 3
Canonical LRのstate 18と20はどちらも

A -> a a •
B -> a a •
C -> a a •

でisocoresなので、LALRではstate 18にまとめられている。その結果bのときにR/Rが起きるようになる.

Canonical LRのstate 20において"baa"はviable prefixである。(0, 4, 19, 20)と遷移する。次のtokenがbのときR7でreduceする。
LALRの場合は(0, 4, 17, 18)と遷移し同じくR7でreduceする。"baa" + bという場合、両者に差はないということになる。

Canonical LRのstate 18において"aaa"はviable prefixである。(0, 3, 17, 18)と遷移する。次のtokenがbのときR8でreduceする。
LALRの場合は(0, 3, 17, 18)と遷移しR7でreduceしてしまう。そしてstate 3で S -> a • A b となり、最終的にsyntax errorになる。
LALRのstate 18におけるbのコンフリクトはCanonical LRのstate 18からみて、mysterious new conflictといえる。


#### 2.5.2. Mysterious invasive conflicts

Table 1 state 9はCanonical LR, LALRの両方のケースでS/R conflictである。これをreduceするようにしたとする。
すると"aaa"はvalidに、"aaaa"はsyntax errorになる。
"ba • b"や"ba • ab"の場合は(0, 4, 11)と進行し、前者はrecude、後者はshiftで最終的にどちらもvalidになる。
LALRの場合に"ba • ab"を与えた場合は(0, 4, 9)と進行しreduceし、最終的にsyntax errorになる。

Canonical LRのstate 9の段階ですでにconflictは存在していたので、これはnewと言い難い。state 11をstate 9にmergeした結果、state 11のactionが変わってしまったので、mysterious invasive conflictsと名付ける。


#### 2.5.3. Mysterious mutated conflicts

Table 3のCanonical LR state 20 は"a"のときR8とR9でR/R conflictしている。Canonical LRでisocoreなstate 18では"a"のときはR7でreduceすればよくconflictはない。
この2つをmergeしたLALRのstate 18を考える。"aaa • a"のようにCanonical LR state 18で次のtokenが"a"であるとき、LALRではconflictがおきているが、その解決はCanonical LRのときの結果と変わらない。一方で"baa • a"のようにCanonical LR state 20のprefixだとLALRのstate 18の挙動が変わっている。


## 3. The IELR(1) algorithm

### 3.1. Overview

### 3.2. Phase 0: LALR(1)

DeRemerのgoto follow setとはfollow setのこと?

#### Definition 3.1 (Efficient LR(1) State)

LALR(1)のstate集合 A(G) の要素sついて(C, At, Ar)の組を定める.

* C: カーネル項集合
* At: transitionの集合. 各要素は(RHS[d], s'), つまり次のsymbolと遷移先のstateのペア.
* Ar: reduceの集合. 各要素は(K, ap), つまりlookahead setとreduceに使用するruleのペア.

#### Observation 3.2 (Lookahead Propagation Path)

follow setとは端的にいえば state s, 非終端記号 A, 終端記号の集合 Tの関係で、state sにいてAで遷移したあとにその直後にくることのある終端記号の集合のことである.
state sにいて、Rule A -> ... でreduceしてよいかを決めるのにLA集合を求める必要がある。LA集合とはつまるところ、いくつかのstate s'と非終端記号 Aのfollow setを合算したものである. ここでいくつかのstate s'はstate sに至る経路に出現するいくつかのstateで、state sから計算する. このstate s'の計算がlookback.

以下Table 1を参照

1. Reductionのlookahead setは(当然)関連するitem(カーネル項)のlookahead setから決まる
   state 9のR3の場合、state 9の最初のitemのlookahead setから決まる

2. (たぶん1で考察している)カーネル項のlookahead setは、predecessorなstateのなかのdotをひとつ左に動かしたitemのlookahead setから決まる. これが非カーネル項のこともある

   state 9のpredecessorはstate 3,4. dotを左に動かしたものはstate 3,4の2つめのitem.

   state 9 (1): A -> a •
   state 3 (2): A -> • a
   state 4 (2): A -> • a

3. 非カーネル項のlookahead setは、その非カーネル項の左辺でいまのstateをgotoしたさきのstateのfollow set.

   state 3,4の非カーネル項のlookahead setは、state 3,4の最初のitemをAでgotoしたときのfollow set.

   state 3 (1): A -> a • A a
   state 3 (2): A -> • a
   state 3 (3): A -> • a a

   state 4 (1): A -> a • A b
   state 4 (2): A -> • a
   state 4 (3): A -> • a a

4. follow setのもとは2つあり
  a. 1つgotoした状態で次にくる終端記号がfollow setになる
     Aでgotoしたあとのstate 3のfirst itemはaを, state 4はbを含んでいる
  b. gotoした状態で残りがnullableであれば、goto後のstateのlookahead setがfollow setになる
     このケースでは
     * lookahead setの計算のためにfollow setを考える必要がある
     * follow setの計算のためにlookahead setを考える必要がある
     もしstate 3をAでgotoしたとき残りがnullableだとした場合、follow setの計算のためにgoto後の状態のlookahead setを考える

#### Definition 3.4 (Goto Tables)

gotoとは非終端記号(V)による遷移.
ngotosはgotoの総数.

gをgotoの1つとするとき

* from_state[g]. gに対応する遷移元state
* to_stage[g]. gに対応する遷移先state
* goto_follows[g]. gのfollow set

state sからs'へ非終端記号Aでgoto遷移したとき

* s  = Σ[from_state[g]]
* s' = Σ[to_state[g]]
* A  = †(Σ[to_state[g]])
* 遷移 δ(Σ[from_state[g]], †(Σ[to_state[g]])) = Σ[to_state[g]]

### 3.2.3. Computing goto follows

DeRemerのいう reads を successor dependencies とここではよぶ.
DeRemerのreadsは2つのgotoに関する関係であった。
state s, s', s''と非終端記号A, Bがあったとき、(s, A) reads (s', B)というのは

s -(A)-> s' -(B)-> s'' であり、B =>* ε

relation Fの反射的推移的閉包を F*(g, g')と表す.

* 反射: g = g'
* 推移閉包: F+(g, g')

cf: https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E9%96%A2%E4%BF%82

direct readは反射によって表現できる。indirect readは推移によって表現できる。

```
      # `DR(p, A) = {t ∈ T | p -(A)-> r -(t)-> }`
      #   where p is state, A is nterm, t is term.
      #
      # `@direct_read_sets` is a hash whose
      # key is [state.id, nterm.token_id],
      # value is bitmap of term.
      @direct_read_sets = {}

      # Reads relation on nonterminal transitions (pair of state and nterm)
      # `(p, A) reads (r, C) iff p -(A)-> r -(C)-> and C =>* ε`
      #   where p, r are state, A, C are nterm.
      #
      # `@reads_relation` is a hash whose
      # key is [state.id, nterm.token_id],
      # value is array of [state.id, nterm.token_id].
      @reads_relation = {}

      # `@read_sets` is a hash whose
      # key is [state.id, nterm.token_id],
      # value is bitmap of term.
      @read_sets = {}

      # `(p, A) includes (p', B) iff B -> βAγ, γ =>* ε, p' -(β)-> p`
      #   where p, p' are state, A, B are nterm, β, γ is sequence of symbol.
      #
      # `@includes_relation` is a hash whose
      # key is [state.id, nterm.token_id],
      # value is array of [state.id, nterm.token_id].
      @includes_relation = {}

      # `(q, A -> ω) lookback (p, A) iff p -(ω)-> q`
      #   where p, q are state, A -> ω is rule, A is nterm, ω is sequence of symbol.
      #
      # `@lookback_relation` is a hash whose
      # key is [state.id, rule.id],
      # value is array of [state.id, nterm.token_id].
      @lookback_relation = {}

      # `@follow_sets` is a hash whose
      # key is [state.id, rule.id],
      # value is bitmap of term.
      @follow_sets = {}
```

#### Definition 3.5 (Goto Follows Successor Relation)

GFs(g, g') で表す.

goto gとg'について以下の条件を全てみたすとき, GFs(g, g')関係が成立する.

* to_state[g] = from_state[g']. つまり s -(g)-> s' -(g')-> s''
* †(Σ[to_state[g']]) =>* ε. つまり goto g'のときに使用した非終端記号がnullableということ.

注: (state 3) = †(S -> a • Aa) = a

これはそのまま Reads relation のこと.

#### Definition 3.6 (successor_follows)

successor_follows[g]. GFs*(g, g')なg'について s' -(g')-> s'' -(t)-> s''' となる終端記号tの集合.

g  = g'のとき: gでの遷移の直後に出現するtoken (direct read)
g != g'のとき: s -(g)-> s' -(g')-> s'' -(t)-> s''' . ただしGFs(g, g')なのでgoto g'のときに使用した非終端記号がnullable. (indirect read)

これはそのままRead setのこと.


DeRemerのいうincludes_relationを2つのケースにわける. Observation 3.2も参照.

* internal dependency: 同じ状態内部でgotoするケース
  * Point 4b: gotoした状態で残りがnullableであれば、goto後のstateのlookahead setがfollow setになる
  * Point  3: 非カーネル項のlookahead setは、その非カーネル項の左辺でいまのstateをgotoしたさきのstateのfollow set
* predecessor dependency: predecessorな別のstateを考慮するケース
  * Point  2: カーネル項のlookahead setは、predecessorなstateのなかのdotをひとつ左に動かしたitemのlookahead setから決まる


#1は1つのstateの内部で、カーネル項と非カーネル項の間にincludes_relationが発生するケースがあるといっている.

State 16 (Table 4):
1. A -> a • C D E
2. C -> • D
3. D -> • a

(s16, D) includes (s16, C) iff C -> βDγ, γ =>* ε, s16 -(β)-> s16
ただし β = ε (DeRemerではβは一般に V* なので任意の0個以上のsymbolの並びでよい)


この辺gotoだけをずっと考えているなとおもったけど、lookahead setはreduceを決定するのに必要で、reduceするともれなく非終端記号が生成され次にgotoが走るのだから、gotoだけをずっと考えているのも当然か.

そういう意味ではitemの次のsymbolが終端記号のときはshiftする一手なのでgotoとは無関係.
state 16 (3): D -> • a

itemの次のsymbolが非終端記号のときはgotoする.
state 16 (1): A -> a • C D E


#### Definition 3.7 (Goto Follows Includes Relation)

GFip(g, g')で表す.
あとでGFiとGFpに分解する.
iはInternal, pはPredecessor.

goto gとg'について以下の条件を全てみたすとき, GFip(g, g')関係が成立する.

αをsymbolの0個以上の列, βを非終端記号の0個以上の列とする.

* g'を s1 -(A)-> s2
* g を s3 -(B)-> s4

1. LHS = A, RHS = α B β となるようなruleが存在する
2. s1 から α の遷移で s3 に移動する
3. βはnullable


#### Definition 3.8 (Goto Follows Internal Relation)

GFi(g, g')で表す.

GFip(g, g')のうちαが空のもの.

* g'を s1 -(A)-> s2
* g を s3 -(B)-> s4

1. LHS = A, RHS = B β となるようなruleが存在する
2. s1 から 無の遷移で s3 に移動する. つまり s1 = s3
3. βはnullable

* g': s1 -(A)-> s2
* g : s1 -(B)-> s4

このとき必ずgのfrom stateがg'のfrom stateの非カーネル項になる. つまりfrom_state[g'] = from_state[g].

#### Definition 3.9 (Goto Follows Predecessor Relation)

GFp(g, g')で表す.

GFip(g, g')のうちαが空でないもの.
A -> α B β

このとき結果的に(いくつかほかのstateを間にはさんで), Σ[to_state[g']] は Σ[to_state[g]] のpredecessorになる.

#### Observation 3.10 (GFip <=> GFi ∨ GFp)

GFipをαが空か否かで分類しているので、それはそう。

#### Definition 3.11 (Goto Follows Dependency Relation)

GFsip(g, g')で表す.

Definition 3.5 (Goto Follows Successor Relation) からGFs(g, g')をもってきて、以下3つの和をとる。

* GFs
* GFi
* GFp


goto gとg'について以下の条件を全てみたすとき, GFs(g, g')関係が成立する.

* to_state[g] = from_state[g']. s -(g)-> s' -(g')-> s''
* †(Σ[to_state[g']]) =>* ε. goto g'のときに使用した非終端記号がnullableということ.


goto gとg'について以下の条件を全てみたすとき, GFip(g, g')関係が成立する.

αをsymbolの0個以上の列, βを非終端記号の0個以上の列とする.

* g'を s1 -(A)-> s2
* g を s3 -(B)-> s4

1. LHS = A, RHS = α B β となるようなruleが存在する
2. s1 から α の遷移で s3 に移動する
3. βはnullable

GFip(g, g')のうちαが空のものがGFi
GFip(g, g')のうちαが空でないものがGFp


g': s1 -(A)-> s2
    |
g : +-(α)-> s3 -(B)-> s4 -(β)->


例えばState 6 (Table 6):
1. A -> B • C (G12)
2. C -> • D   (G13)
3. D -> •     (R7)

このときGFiを考えると"C: D"というruleは存在するが、"D: C"というruleは存在しないので、GFi(#2, #1)は成り立つが、GFi(#1, #2)は成り立たない。

1: s1 -(C)-> s2
    |
2: s1 -(D)-> s4 -(ε)->

2: s1 -(D)-> s2
    |
1: s1 -(C)-> s4 -(ε)->


#### Definition 3.12 (goto_follows, Oversimplified)

GFsip = GFs ∨ GFi ∨ GFp としてそのいずれかにあてはまるとき、つまりGFsip*(g, g')のときのg'を考え、g'からtoken tによる遷移をもって goto_follows[g] を構成する.

#### Observation 3.13 (Successor Not Before Predecessor).

Definition 3.12が不十分であることをtable 6で考える.
state 2 -> state 6とstate 4 -> state 6が問題.
goto state 6 G12とgoto state 2 G3、goto state 6 G12とgoto state 4 G5はどちらもGFpの関係.
goto state 2 G6とgoto state 6 G12、goto state 4 G6とgoto state 6 G12はどちらもGFsの関係.
しかしそのfollow setsは{ab}ではなく、それぞれ{a}と{b}である. これが"there are some goto follow sets that inherit some successor goto follow sets only partially"の例 (successorはgoto state 6 G12).

successor dependencyからfollow setsを作る箇所に考慮が必要.
なので successor dependency をたどったあとはそのtokenをshiftしている必要があるという制約をつける。

#### Definition 3.14 (goto_follows, via successor_follows)

goto_follows[g]は

* GFip*(g, g')をみたすgoto g'があるとき
* successor_follows[g'] なtokenの集合を足し合わせたもの


#### 3.2.4. Bison implementation

この段階でBisonに変更はほとんど必要なく、ただgoto tableを外から触れるようにするだけ.

### 3.3. Phase 1: Compute auxiliary tables

IELRはstateを分割するが、その分割前後でRuleとDotの組(core)は変化しない。
shiftはcoreから決定するので、stateの分割はshiftについては影響しない。
一方でstatの分割でlookahead propagationは変化するので、lookahead setとreduceは変化する。
IELRのstate分割ではもっぱらlookahead propagationのpathの変化について注目する。

Phase 0のdependency relationsは単純化されたものなので、Phase 1ではさらに細かい依存関係を調べる.

以下では

* predecessors
* follow_kernel_items
* always_follows

を順番に説明する。

#### 3.3.1. Predecessors

stateの分割前後で何が変わるかというと、対象のstateのpredecessorsが変わる.
具体的にはlookback relationが変わる.

Table 4のstate 18についてpredecessorsを考えてみると、以下のように途中に分岐を挟みながらstate 0(開始状態)へ戻っていくことができる.

* λ1: (0, 2, 16, 17, 18)
* λ2: (0, 5, 16, 17, 18)

このようなときIELRはstate 16, 17, 18 を分割し、lookahead set {ac}と{bc}が混ざらないようにする必要がある.
Phase 3でstateの分割を行う.
Phase 2ではconflictな状態からstart stateに遡りつつ分割するべきstateにannotateをする.
Phase 1ではPhase 2で遡っていくために必要な情報として predecessors table を計算する.


再掲:
例えばstate 4からAでstate 6へ、aでstate 11へ移動するとき、state 4はstate 6や11のpredecessor、state 6や11はstate 4のsuccessorsと呼ぶ.

* state 4 (predecessor) -> state  6 (successors)
* state 4 (predecessor) -> state 11 (successors)

##### Definition 3.15 (Predecessors)

state s, s'とsymbol yを考える.
predecessors[s] は s' -(y)-> s となるようなyが存在するs'全体の集合.

つまり、state sに1回の遷移で到達できるstate s'の集合のこと.

#### 3.3.2. Goto follows from kernel items


##### Definition 3.16 (follow_kernel_items)

state sの非カーネル項のfollow setsが、おなじstate sのカーネル項のlookahead setsに依存しているかどうか.

goto gについてその始点の状態を考える Σ[from_state[g]] = (C, At, Ar).
C(カーネル項集合)のそれぞれの項を k で指定する.

follow_kernel_items[g][k] は以下を全て満たすときにtrue

1. GFi*(g, g') ∧ R[d] = †(Σ(to_state[g']))
   ∧ の右側の条件はg'がカーネル項といっている?
2. R[d + 1 ... |R|] =>* ε
   Cが "sym1 • sym2 sym3 ..." のとき、"sym1 sym2 • sym3 ..." を考える. "sym3 ..." が =>* ε である.
   カーネル項で一回gotoしたあとの右辺がεにならないのであれば、カーネル項のfollow setsに依存しており、lookahead setsに依存していないため


State 6 (Table 6):
1. A -> B • C (G12)
2. C -> • D   (G13)
3. D -> •     (R7)

g  = G13 (state 6 -> state 13 by nterm D)
g' = G12 (state 6 -> state 12 by nterm C)


再掲:
* C: カーネル項集合
* At: transitionの集合. 各要素は(RHS[d], s'), つまり次のsymbolと遷移先のstateのペア.
* Ar: reduceの集合. 各要素は(K, ap), つまりlookahead setとreduceに使用するruleのペア.

#### 3.3.3. Always-generated follows

3.3.1 でpredecessorsとlookback relationが変化するといったので、ここではsuccessorとinternal dependencyについて考察する.

core(RuleとDotの組)がsuccessorのcoreを生成するし、coreが自身のinternal dependencyを生成するので、successor dependencyもinternal dependencyもcoreにのみ依存する.
stateの分割はcoreを複製するので、successor dependencyもinternal dependencyもまた複製される.

##### Definition 3.17 (Goto Follows Always Relation)

GFsi(g, g') = GFs(g, g') ∨ GFi(g, g').


Table 4 & 5
* s   = state 16 (LALR)
* s'  = state 16 (IELR)
* s'' = state 19 (IELR)

Nterm Cによるsuccessorはそれぞれ以下の通りであり、successor dependencyが複製されている。
* s   -> state 17
* s'  -> state 17
* s'' -> state 20

internal dependencyはそれぞれが C -> • D を保持している.

state sを開始地点としてgoto follow setのalways dependencyな依存関係を辿っていったpathをpとする.
このpathはどこかの地点でshiftに遭遇してstopする。s'に対するp'、s''に対するp''はpと同様のcoreの遷移をし、そのfollow setも同じものになる.


##### Definition 3.18 (always_follows, two closure)

successorとinternal dependencyに基づくfollow setの計算はstate分割後も変わらないことがわかったので、この部分を定式化する。

goto gに対してtokenの集合always_follows
always_follows[g] = { GFi*(g, g') となる g'の successor_follows[g'] }

goto_followsとの差異は、goto_followsが GFip* なのに対して、always_followsは GFi* .

GFiによって本当にfollow setが生成されるのか?
される。GFiは同じstate内の非カーネル項からカーネル項へのdependencyなので、カーネル項のsuccessorが非カーネル項のfollow setの一部になる.

##### Definition 3.20 (always_follows, one closure)

successor_followsの計算がclosureの計算を必要とするので、always_followsを別の形で定義する.

always_follows[g] = { GFsi*(g, g') となる g'について　δ(Σ[to_state[g']], t) となる token t }

以下ではこの2つのalways_followsの定義が等しいことをしめす.

##### Theorem 3.22

successor -> internal dependency のとき直接successorになる.

#1,4はsuccessorの定義から、#2,3,5はinternal dependencyの定義から.

##### Corollary 3.23

GFsi*(g, g')は複数のgotoの列のこと。
列の隣接する要素間の関係は GFs or GFi.
GFs GFi の順になっている個所はGFsに置き換えられる (Theorem 3.22).
ということは g GFi GFi ... GFi GFs ... GFs g'に置き換え可能.
ちょうど切り替わるところをg''とすればよい.

#### 3.3.4. Goto follows reconsidered

goto_followsのtokenを決定するsuccessor_followsをalways_followsに置き換えても同値といっている.


#### 3.3.5. Bison implementation

### 3.4. Phase 2: Compute annotations

Phase 2ではconflictしたstateから開始状態に遡りつつ、Phase 3でstateを分割するさいに必要となる情報をannotateしていく。
必要となる情報とは、そのstateがLR(1)-relative inadequaciesにどう関係しているかという情報であり、具体的には

* kernel item lookahead sets
* goto follow sets

を経由したconflicted tokens’ propagation pathsである。

#### 3.4.1. Item lookahead sets

##### Definition 3.26 (item_lookahead_sets)

state s = (C, At, Ar)

* C: カーネル項集合
* At: transitionの集合. 各要素は(RHS[d], s'), つまり次のsymbolと遷移先のstateのペア.
* Ar: reduceの集合. 各要素は(K, ap), つまりlookahead setとreduceに使用するruleのペア.

カーネル項をそれぞれkで識別する.
symbolをx, y, zとする.

item_lookahead_sets[s][k] を以下のようにさだめる

1. d > 2.
   item_lookahead_sets[s][k] = "d - 1"としたときの item_lookahead_sets.
   これは "A -> x y • z ..." のときで、state sと同じルールと"d - 1"でひとつ前の状態を表現できる
   このときstate sのpredecessorsをstate s'とする. s'のうち (L -> R, d - 1)なもののitem_lookahead_sets
2. d = 2.
   item_lookahead_sets[s][k] = goto_follows[g].
   これは state s "A -> x • y ..." のときで、その直前は state s' "B -> ... • A ...".
   g = s' -(A)-> s''
   predecessors[s] = s'
3. d = 1.
   item_lookahead_sets[s][k] = {}.
   これはruleが "S' -> • S #" のときなので。

#### 3.4.2. Annotation lists

##### Definition 3.27 (inadequacy_lists)

state s、token tについて

inadequacy_lists[s] = {(s, t, Γ(t, Σ[s]))} ただし Γ(t, Σ[s]) > 1

Γ(t, Σ[s])はstate sでtoken tのときにどのような動作をするか

##### Definition 3.28 (Inadequacy Annotation)

基準となるstateがあり、そこから分割で生成されるstateにおけるconflictを考えるので

* あるstate s
* あるstate s'
* あるtoken t
* |Γ(t, Σ[s'])| 長のマトリクスγ. γの長さは |Γ(t, Σ[s'])| * |C|, つまり コンフリクト数 * カーネル項の数

を用いる.

state s = (C, At, Ar)

* C: カーネル項集合
* At: transitionの集合. 各要素は(RHS[d], s'), つまり次のsymbolと遷移先のstateのペア.
* Ar: reduceの集合. 各要素は(K, ap), つまりlookahead setとreduceに使用するruleのペア.

state sのinadequacy annotationとは組(ni, γ)のこと。
これはコンフリクトしているstateとtoken(ni) & 

inadequacy_listsに含まれるstateを s'とする。

Inadequacy Annotation ni = (s', t, Γ(t, Σ[s']))

Inadequacy Contribution Matrix γの長さは |Γ(t, Σ[s'])| つまりコンフリクトの数と同じ。
γ[i]は|C| つまりカーネル項の数と同じ。

(a) undefined. always contributionのとき
(b) Boolean sequence. それぞれの要素 γ[i][j]は
  1. potential contributionのときにtrue
  2. never contributionのときにfalse

具体的な計算は annotation_lists の構築をもってかえる.

##### Definition 3.29 (annotation_lists)

annotation_lists[s]は (Inadequacy Annotation ni, Inadequacy Contribution Matrix γ) の集合

* annotation_lists
  * annotate_manifestation
    * compute_lhs_contributions
  * annotate_predecessor

##### Definition 3.30 (annotate_manifestation)

annotate_manifestation(state s, Inadequacy Annotation ni) = (Inadequacy Annotation ni, Inadequacy Contribution Matrix γ)

1. コンフリクトがShiftの場合は γ[i] = undefined. 多分shiftはstateが決まると他への依存に関係なく決まるからだと思う
2. コンフリクトがReduceの場合, L -> R というruleでreduceするとする
  (a). γ[i][j] = true if C[j] = ((L -> R), |R| + 1). これはいままさしく議論しているカーネル項のことですね
  (b). R = εのとき. γ[i] = compute_lhs_contributions(s, L, t). たぶんこれは非カーネル項の可能性がある

##### Definition 3.31 (compute_lhs_contributions)

この関数は |C| の長さのbooleanの列をかえす.
引数のstate s から引数のNterm Lによる遷移をgとする

1. tがalways_follows[g]に含まれるとき, undefined (always contribution)
2. tがalways_follows[g]に含まれないとき, follow_kernel_items[g][i] かつ item_lookahead_sets[s][i]ならtrue (potential contribution)


Table 4を例として.

State 18は token "a" でコンフリクトし、2つのcontributionsがある.

1. (S, nil)
2. (R, R9)

#1はShiftなので γ[1] = undefined
#2はruleの右辺がεなので、compute_lhs_contributions(state 18, E, "a")

compute_lhs_contributionsの計算:
* state 18からEによる遷移 g = G14 とする
* gにとって"a"はalways_followsではない
* follow_kernel_items[g][1]はtrue
  Ruleは A -> a C D • E で、 a C D E • の残りはε
* item_lookahead_sets[state 18][1]はaを含むの
  d > 2のケース.

よって γ[2][1] = true.


1. GFi*(g, g') ∧ R[d] = †(Σ(to_state[g']))
   ∧ の右側の条件はg'がカーネル項といっている?
2. R[d + 1 ... |R|] =>* ε
   Cが "sym1 • sym2 sym3 ..." のとき、"sym1 sym2 • sym3 ..." を考える. "sym3 ..." が =>* ε である.
   カーネル項で一回gotoしたあとの右辺がεにならないのであれば、カーネル項のfollow setsに依存しており、lookahead setsに依存していないため

LALRのstate 18はIELRのstate 18と21に分割される。
Shift(S 15)はalways contributionなので、state 18とstate 21の両方で引き続き出現する.
R9によるreduceはpotential contributionであり、state 18には残るが21からは消える。

##### Definition 3.32 (annotate_predecessor)

annotate_predecessor(State s, State s', (Inadequacy Annotation ni, Inadequacy Contribution Matrix γ)) = (Inadequacy Annotation ni, Inadequacy Contribution Matrix γ)

state s -> state s'のとき、s'のannotaionからsのannotationを計算する.

* state s
* predecessors[s']にsをふくむようなstate s'
* annotation_lists

1. undefined
  a. s'におけるshiftのconflictはそのままsに引き継ぐ
  b. s'が"A -> x • y ..."のとき compute_lhs_contributions(s, A, t) = undefined
2. true
  a. s'のdotをひとつ左に移動するとsになるとき、
  b. 


Table 4を例として.

State 17はState 18のpredecessors.
* s = 17
* s' = s'' = 18
* t = a
* s 18のannotationをγ'とする
  γ'[1] = undefined, γ'[2][1] = true.
* C  = (A -> a C • D E, 3)
* C' = (A -> a C D • E, 4)
* 定義より|γ| = 2とする
* γ[1] = undefined (γ'[1] = undefinedなので, #1)
* γ[2][1] = true (γ'[2][1] = true, L = L' & R = R' & 3 = 4 -1, #2(b)1)


s, s', s''の関係がちょっとわからない.
本紙で検討している(s, s', s'', token)の組み合わせは

* (17, 18, 18, a)
  * γ[1] = undefined
  * γ[2][1] = true

* (16, 17, 18, a)
  * γ[1] = undefined
  * γ[2][1] = true

* ( 2, 16, 18, a)
  * γ[1] = undefined
  * γ[2][1] = undefined
  * cf: 3.4.3.


sとs'は s -> s' (predecessors)の関係なのでいいとして、問題はs'とs''。s''はannotation_lists[s']から生成されている。
annotation_listsのうち#1 annotate_manifestationは引数のstate sから直接Inadequacy Annotation niを生成する。
#2 はs -> s'なs'にたいして再帰的にannotation_lists[s']を呼ぶので複数回のpredecessorsの関係になりうる。この再帰はinadequacy_lists[s'']が存在するs''まで進む。
処理としてはコンフリクトのあるstate(18)から17, 16と遡って計算することになる。


#### 3.4.3. Split-stable dominant contributions

(s, s', s'') = (2, 16, 18)のケース
* γ[1] = undefined
* γ[2][1] = undefined
  compute_lhs_contributions(2, A, a)を計算する(annotate_predecessor #1bのケース). always_follows[g]はaをふくむ

ここでstate 18のaに関する2つのconflictについて、state 2が両方のconflictに関してalways contributionになる。

(s, s') = (0, 2)のケース
undefinedで表現されるalways contributionはそのpredecessorにalways contributionとして引き継がれるため、state 0のcontribution matrixはstate 2と同じになる(false: never contribution も同じであると後述されている)

(s, s', s'') = (5, 16, 18)のケース
* γ[1] = undefined
* γ[2][1] = false
  compute_lhs_contributions(5, A, a)を計算する(annotate_predecessor #1bのケース).
次のPhaseではstate 2から18とstate 5から18が混ざらないように分割をする。

(s, s') = (0, 5)のケース
always contributionもnever contributionもそのままpredecessorに引き継がれるのでstate 0のcontribution matrixはstate 5と同じになる

##### Observation 3.33 (Simple Split-Stable Dominance)

すべてのcontributionsがalways contributionsもしくはnever contributionsのときsplit-stable dominant contributionとなる.

split-stable dominant contributionだからといってすべてのcontributionsがalways contributionsもしくはnever contributionsとは限らない。


##### Observation 3.34 (Useless Inadequacy Annotations)

##### Definition 3.35 (Split-Stable Dominant Contribution)

### 3.5. Phase 3: Split states

Phase 3では非カーネル項を再計算する必要はない。

* follow_kernel_items
* always_follows
* phase 0’s goto tables

をつかう。

以降ΣはPhase 3のその時点までで計算したstateの集合とする。Phase 3の開始時点ではPhase 0で計算したLALRのそれと等しい。
Phase 3では新しく作ったstateに対してより高い優先度をあたえる(a higher index)。

#### 3.5.1. Tracking isocores

##### Definition 3.36 (lalr1_isocores)

IELRでは複数のstateが同じcoreをもつことがあるので、IELRのstateから対応するLALRのstate(LALR(1) isocore)を取り出せるようにしておく。

lalr1_isocores[s]はsに対応するLALR(1) isocoreを返す.


##### Definition 3.37 (isocore_nexts)

state sのIsocore Set(= I(s, Σ))で循環linked listをつくる。
isocore_nexts[s]はそのlinked listの次の要素をかえす。
Isocore Setのlistなのでcoreが同じ別のstateがかえる(coreが同じstateが1つなら自身がかえる)


#### 3.5.2. Item lookahead sets

##### Definition 3.38 (lookahead_set_filters)

Phase 3ではstateの分割にともなってitem_lookahead_setsが変化するので、Phase 2で計算したitem_lookahead_setsをそのまま使うことはできない。
分割で変化しうるのはinadequacy annotationsに登場するlookaheadだけなので、全部を再計算する必要はない。
再計算が必要かを判定するための関数として lookahead_set_filters を用意する。

1. |lookahead_set_filters[s]| = |C|. state sのカーネル項の個数と同じ
2. lookahead_set_filters(s)[j] = annotation_lists[lalr1_isocores[s]] のγのうち γ[i][j] = true となるようなtoken tの集合

##### Definition 3.39 (compute_goto_follow_set)

compute_goto_follow_set(State s, Nterm n) = 以下をみたすtoken tの集合

* s -(n)> s' となるgoto g
* always_follows[g] OR follow_kernel_items[g][k] AND item_lookahead_sets[s][k] となるtoken t


##### Definition 3.40 (propagate_lookaheads)

lookaheadsをstate sからsuccessorに分配する。

* state s, s'
* symbol y. ただし s -(y)> s'

* |propagate_lookaheads(s, s')| = |C'| (state s'のカーネル項の数と等しい)

1. d' > 2のとき. d' > 2ということはs'とsはおなじruleでdotの位置がひとつ違う. sのitem_lookahead_setsのうちs'のlookahead_set_filtersになっているものが対象.
2. d' = 2のとき. d' = 2ということはs'とsのruleは異なる. item_lookahead_setsのかわりにsのcompute_goto_follow_setを使う.


##### Definition 3.41 (lookaheads_recomputed)

Phase 3はlookaheads_recomputed[s]をfalseで初期化して、lookaheadsを最低一つでも再計算したときにtrueに変える.


#### 3.5.3. State compatibility

##### Definition 3.42 (dominant_contribution)

* state s
* sのinadequacy annotation na
* lookahead sets K

を引数にとり、Kのもとでのsのnaに対するdominant contributionを計算する.
具体的にはあたらしくConflict Contribution Γ'を計算する.


##### Definition 3.43 (is_compatible)

##### Definition 3.44 (Merge Stability).

### 3.6. Phase 4: Compute reduction lookaheads

通常のLALR計算時と同じ方法でlookaheadsを計算する.

### 3.7. Phase 5: Resolve remaining conflicts

通常と同じ方法でconflictを解決する。

* precedenceとassociativityによる解決
* S/RはSに解決する
* R/Rは定義順が上のRで解決する
