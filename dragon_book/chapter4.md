# 4 構文解析

エラー回復とやらを説明してもらおうじゃないか。

P. 205: ここでいう"ある文法のクラス"というのはチョムスキー階層の話だと思う。

曖昧性を検知してくれるって書いてあるじゃん!

## 4.1

### 4.1.1

上向き、下向きという分類はあまり好きではない。

### 4.1.2

`while ... `や `int i;`のような構文は`while`や`int`を読んだ時点で決定可能なことが多いので簡単。
一方で`1 + 2 * 3`などはどこまでで塊とするかが、`1`を読んだ時点で決まらない。
左から右へ読んでいくため構文の先頭で決定できるケースが一番簡単。

(4.1)は結合の強いものをより小さい単位にすることで優先度を表現する典型的な例。

(4.2) 左再帰除去した形は読みにくいので、手で書きたくないなって思ってしまう。

### 4.1.3

可延頭部。字面がひどい。
言いたいことは `def m()) ...` という不正な入力があったときに `def m())`の時点でそのようなトークン列は文法規則から導けないとわかるということ。

### 4.1.4

パニックモード: `;`や`}`のような構文の終端を表現するトークンがlexerから返ってくるまで入力を捨てていく方法。
手書きで作るときはおそらくこれになる。

句レベルの回復: 大域的訂正を局所的に使うものをこう呼ぶらしい。CPCT+ とかはこれに該当するんだと思う。

エラー生成規則: Rubyにもある https://github.com/ruby/ruby/blob/fabec3909c225a0bb8392f02123c73f426e79219/parse.y#L6998-L7034 とか。PythonもPEGでこれをやっている。

```shell
$ ruby -e 'def m(A); end'
-e:1: formal argument cannot be a constant
def m(A); end
-e: compile error (SyntaxError)
```

大域的訂正:

## 4.2 文脈自由文法

### 4.2.1

開始記号: Rubyでいうところの`program`。 https://github.com/ruby/ruby/blob/fabec3909c225a0bb8392f02123c73f426e79219/parse.y#L2921

### 4.2.2

これはわからなくなったら適宜みればよい。
注意点は記号と記号列があることと、αなど終端・非終端を気にしない記号の列があること。

### 4.2.3

導出は非終端記号を展開していく作業。展開することでその文法から言語(記号列の集合)が生成される。

正規表現でおなじみ、`*`は0回以上、`+`は1回以上の繰り返し。

2つの文法が同じ言語を生成する話。DPDAの等価性判定が決定可能であることは証明されている。

https://en.wikipedia.org/wiki/Deterministic_pushdown_automaton#Equivalence_problem

最右と最左の矢印のしたにかいてあるのは、Left MostとRight Most。

### 4.2.5

曖昧性とは最右もしくは最左のように導出の順番を固定したうえでも、2通り以上の解析木が作れること。

## 4.3 文法の記述

ここで"文法"とは文脈自由文法のこと。

### 4.3.2

(4.10)

* if E1 then (if E2 then S1 else S2) # 通常はこっちの解釈にする言語が多い
* if E1 then (if E2 then S1) else S2

この辺がS/Rコンフリクト時にデフォルトでshiftすることの理由。

### 4.3.4

左端のくくり出しをみていると、なぜ人間が機械に合わせないといけないのかと思ってしまう。
LRの場合は判断を留保できるので、オリジナルな書き方でよい。

### 4.4.3

P.240 3は導出する場合、αなのかβなのかが判別できないため。

P.243 解析表の使い方は、例えば E -> T E' で T まで解析が終わったときに次の非終端記号E'を解析するとする。このとき次の入力が+であれば E' -> + T E' を、)であれば E' -> ε を適用する。

### 4.4.5

"synch". 例えば FOLLOW(T)は+を含んでいる。ということは T + ... となることがあり、そのときに+に遭遇したのであればTの解析を全部やめて進むのが合理的という判断。

## 4.5

## 4.6

### 4.6.2

例 4.27. I1からI6へのGOTOのことを説明している。

LR(0)はP.266にあるように、シフトできるならシフト、そうでないなら還元という非常にプリミティブな方法。

### 4.6.4 SLR(1)

LR(0)が生成規則の最後にいるときは常にReduceするという戦略だったのに対して(P. 266)、SLR(1)は `A -> α` という生成規則について次のトークンが FOLLOW(A) のときにだけReduceする戦略をとっている。そのためLR(0)よりも一般にReduceする箇所が少なくなる。

(4.15)はLR(1)やLALRへの伏線。SLR(1)だとコンフリクトするけど、LALRなどではコンフリクトしない例。

### 4.6.5

そもそもハンドルの定義(P. 254)がそこで還元するものなので。

Fに還元というのはP. 263のI11の状態のこと。
もともとの文法はP. 207の (4.1) を参照。

### 4.7.1

ここで再度(4.15)が登場する。
状態2の R -> L・を考える。ここでFOLLOW(R)は`=`を含む。
しかし`R = `から始まる言語は存在しない。それは常に1つ以上`*`が先頭に存在する。
ということは先行する`*`の有無を考慮することで、このコンフリクトは解消できる。

新しい項のフォーマットとして LR(1)項、つまり[A -> α ・ β, a]というように終端記号aを追加したペアにする。
LR(0)項についてはP. 261を参照。
ここで終端記号aの集合は常にFOLLOW(A)のsubsetになる。

### 4.7.2

P. 283のCLOSUREとGOTOの計算を先に読んだ方がよくて。
CLOSUREの計算時には、[A -> α・Bβ, a]からCLOSUREを計算するときに、FIRST(βa)を計算してその終端記号を利用して`B -> γ`という生成規則をCLOSUREに取り込む。具体的には[B -> ・γ, b]を追加する。
これがなにをしているかというと、いままでであれば`A -> α・Bβ`のCLOSUREに`B -> ・γ`を追加すればよかったのだが、今回はさらに1つ先に出現する可能性がある終端記号を考慮する必要がある。
ここでBの直後に出現することがある終端記号は

1. βがεでないときは、βの先頭に出現することがある終端記号
2. βがεであるときは、a

よってFIRST(βa)を計算すればよい。

GOTOの場合はaをそのまま引き継ぐ。

ポイントとしては`S' -> S, $`から計算を始めることかなぁ。

### 4.7.3

### 4.7.4

I4 = [C -> d・, c/d]
I7 = [C -> d・, $]

P.289の例4.42はとても面白い。というかこれをLR(1)の説明に使うべきでは？

S: 
  a A d
  b B d
  a B e
  b A e

aがきたケースでは

a A d
a B e

bがきたケースでは

b B d
b A e

となるので、cをA/Bのどちらで還元するかはそれぞれのケースのd/eで区別がつく。
いやーこういうのどこかの論文で見たわ...
