# 4 構文解析

エラー回復とやらを説明してもらおうじゃないか。

P. 205: ここでいう"ある文法のクラス"というのはチョムスキー階層の話だと思う。

曖昧性を検知してくれるって書いてあるじゃん!

## 4.1

### 4.1.1

上向き、下向きという分類はあまり好きではない。

### 4.1.2

`while ... `や `int i;`のような構文は`while`や`int`を読んだ時点で決定可能なことが多いので簡単。
一方で`1 + 2 * 3`などはどこまでで塊とするかが、`1`を読んだ時点で決まらない。
左から右へ読んでいくため構文の先頭で決定できるケースが一番簡単。

(4.1)は結合の強いものをより小さい単位にすることで優先度を表現する典型的な例。

(4.2) 左再帰除去した形は読みにくいので、手で書きたくないなって思ってしまう。

### 4.1.3

可延頭部。字面がひどい。
言いたいことは `def m()) ...` という不正な入力があったときに `def m())`の時点でそのようなトークン列は文法規則から導けないとわかるということ。

### 4.1.4

パニックモード: `;`や`}`のような構文の終端を表現するトークンがlexerから返ってくるまで入力を捨てていく方法。
手書きで作るときはおそらくこれになる。

句レベルの回復: 大域的訂正を局所的に使うものをこう呼ぶらしい。CPCT+ とかはこれに該当するんだと思う。

エラー生成規則: Rubyにもある https://github.com/ruby/ruby/blob/fabec3909c225a0bb8392f02123c73f426e79219/parse.y#L6998-L7034 とか。PythonもPEGでこれをやっている。

```shell
$ ruby -e 'def m(A); end'
-e:1: formal argument cannot be a constant
def m(A); end
-e: compile error (SyntaxError)
```

大域的訂正:

## 4.2 文脈自由文法

### 4.2.1

開始記号: Rubyでいうところの`program`。 https://github.com/ruby/ruby/blob/fabec3909c225a0bb8392f02123c73f426e79219/parse.y#L2921

### 4.2.2

これはわからなくなったら適宜みればよい。
注意点は記号と記号列があることと、αなど終端・非終端を気にしない記号の列があること。

### 4.2.3

導出は非終端記号を展開していく作業。展開することでその文法から言語(記号列の集合)が生成される。

正規表現でおなじみ、`*`は0回以上、`+`は1回以上の繰り返し。

2つの文法が同じ言語を生成する話。DPDAの等価性判定が決定可能であることは証明されている。

https://en.wikipedia.org/wiki/Deterministic_pushdown_automaton#Equivalence_problem

最右と最左の矢印のしたにかいてあるのは、Left MostとRight Most。

### 4.2.5

曖昧性とは最右もしくは最左のように導出の順番を固定したうえでも、2通り以上の解析木が作れること。

## 4.3 文法の記述

ここで"文法"とは文脈自由文法のこと。

### 4.3.2

(4.10)

* if E1 then (if E2 then S1 else S2) # 通常はこっちの解釈にする言語が多い
* if E1 then (if E2 then S1) else S2

この辺がS/Rコンフリクト時にデフォルトでshiftすることの理由。

### 4.3.4

左端のくくり出しをみていると、なぜ人間が機械に合わせないといけないのかと思ってしまう。
LRの場合は判断を留保できるので、オリジナルな書き方でよい。

