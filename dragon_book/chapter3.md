# 3

* 字句解析器生成系
  * Flexなど
  * CRubyは手書きのlexer(parser_yylex in parse.y)
    * https://github.com/ruby/ruby/blob/f1b95095d6635567cc5820b3eb40d9618faa73ed/parse.y#L10392
  * Lramaも手書きのlexerではあるが、StringScannerが強力なので字句解析器生成系に近い書き心地だと思う
    * https://github.com/ruby/lrama/blob/master/lib/lrama/lexer.rb
* 字句パターン
  * `int [0-9]+` のような記述のこと
  * https://github.com/akimd/bison/blob/25b3d0e1a3f97a33615099e4b211f3953990c203/src/scan-gram.l#L155-L158

## 3.1

### 概要

"場合によっては、構文解析器を支援するために、字句解析器が、識別子の種類に関する情報を記号表から読み取って、構文解析器に引き渡す適切なトークンを決定することもある。"
  * 近いことをやっている例 https://github.com/ruby/ruby/blob/f1b95095d6635567cc5820b3eb40d9618faa73ed/parse.y#L10375


(Cのような行指向の)マクロ展開がある場合はpreprocessをもう一段前に挟むかなぁ


### 3.1.1

どうしてLexerとparserを分けるのか?

1. これは2つのことなるロジックを用意することはサポートするけど、2つに分離することはサポートしない気がする。Rubyの場合 heredoc をparserでやるのは大変なので同意はする。
2. この実行速度の改善は現代でどのくらい効果があるのか
3. これはfile以外のケース or デバイスが特殊なケース or 文字コード?


### 3.1.2

* トークン
  * トークン名: tINTEGER
  * 属性値: 1
* パターン: `[0-9]+`
* 字句: "1 + 2"

### 3.1.3

このFortranの例、厳しい...

### 3.1.4

字句解析器レベルでエラーが出せる例としては

```
% ruby -e "@ 1"
-e:1: `@' without identifiers is not allowed as an instance variable name
-e:1: syntax error, unexpected integer literal, expecting end-of-input
-e: compile error (SyntaxError)
```

修復方法の4は思いつかなかった(実装したくない)。大体のケースでIDENTIFIERになりうるんだよなぁ

## 3.2

CRubyの場合は lex_getline で次の1行を取得する。
https://github.com/ruby/ruby/blob/f1b95095d6635567cc5820b3eb40d9618faa73ed/parse.y#L7475

ファイルのときと文字列(evalや -e option)のときの差を吸収するために実際の処理は`p->lex.gets`関数の呼び出しになっている。
`lex_get_str`や`lex_io_gets`を参照。

RubyのLexer Buffer
https://github.com/ruby/ruby/blob/f1b95095d6635567cc5820b3eb40d9618faa73ed/parse.y#L417-L425


## 3.3

### 3.3.1

文字種のことをアルファベットと言いがち。
|s| で文字列長、ε(イプシロン)で長さがゼロの記号列というのもよくある書き方。

### 3.3.5

先読みとかじゃなくてよかった。

## 3.4

### 3.4.1

この1文字戻す操作はRubyでいうと`pushback`。

### 3.4.2

Rubyは#2を採用していて、一番最後に`parse_ident`が呼ばれる。
https://github.com/ruby/ruby/blob/f1b95095d6635567cc5820b3eb40d9618faa73ed/parse.y#L11108

## 3.5

Flexへの入力ファイルの例: https://github.com/akimd/bison/blob/25b3d0e1a3f97a33615099e4b211f3953990c203/src/scan-gram.l

`%{%}`ではBisonなどの生成するheader fileを読み込むことがおおい。これはheader fileにtokenの定義が書かれているため。

https://github.com/ruby/lrama/blob/7b9313067011fd7f4babe972b1ca53ef1b84a52d/spec/fixtures/integration/named_references.l#L7

例3.13 は流石に先読みしすぎではないか...

## 3.6

### 3.7.1 NFAからDFA

P.166

DFAの開始状態をAとする。
AはNFAの状態0を含む。

A = {0}

状態0から1回のε遷移で移動できる{1, 7}を含む。
{1, 7}から1回のε遷移で移動できる{2, 4}を含む。
{2, 4}から1回のε遷移で移動できるところはない。

よって A = {0, 1, 2, 4, 7}

DAFの状態Aから文字aで遷移した状態、状態Bについて考える。

B = {3, 8}

状態3から1回のε遷移で移動できる{6}を含む。
{6}から1回のε遷移で移動できる{1, 7}を含む。
{1, 7}から1回のε遷移で移動できる{2, 4}を含む。

よって B = {1, 2, 3, 4, 6, 7, 8}

### 3.7.3

これは k(n+m) が十分に小さいときに有効(P. 163のNFA-DFA変換が直接のシミュレーションよりも時間が掛かるという状況)

### 3.7.4

正規表現 -> NFAの生成。

基底ステップの部分式aって文字? 文字列?
"正規表現技術入門" P.124をみたところ、このaは文字。

葉の方から変換していく(数学的)帰納法的なアプローチ。
帰納法なのだからそれ以上分解できない基底ステップと、それらに対する帰納ステップからなる。

基底ステップ: 基底ステップは2つ。1つはεで、もう一つは文字(文字列ではない)

εの場合は入力なしで、状態iから状態fへ移動する。
文字'a'の場合は、入力'a'によって状態iから状態fへ移動する。

帰納ステップ: 4つを考える。

a) r = s|t というsとtの選択

b) r = st という連接

c) r = s* という連続

d) r = (s)

#### 例3.25

n = 3のケースを考える。

... a (a|b) (a|b)

となる。

* x x a a a
  * a a a a (受理)
  * a a a b (受理)
* x x a a b
  * a a b a (受理)
  * a a b b (受理)
* x x a b a
  * a b a a (不受理/次がaでもbでも受理)
  * a b a b (不受理/次がaでもbでも受理)
* x x a b b
  * a b b a (不受理/次が x x なら受理)
  * a b b b (不受理/次が a x x なら受理)

末尾2つの組み合わせを記憶する必要がある。

### 3.8.4

r1 / r2 に合致する文字列があったときに、 '/' に対応する位置をsとして、そこまでが合致したことにしたい。

### 3.9.1

アルゴリズム 3.20 (P.164).

* ε-closure(s)はNFAの状態sをε遷移で膨らませたもの。
* ε-closure(T)はNFAの状態sの集合Tをε遷移で膨らませたもの。
* move(T, a)はTの状態sが入力aによって遷移する先の状態集合。

NFAの状態の集合Tを特徴づけるものは重要状態だという話。
重要状態でない状態はε遷移によって他の状態を集合に取り込むため、集合の境界を決めているのは全て重要状態である。
また重要状態は次の遷移に入力を必要とするため、moveでは重要状態のみをみればよい。

`#`はend of inputだと思えばよい。

> 重要状態は、基底ステップから作られる部品の初期状態によってしか導入されない。

P.171とP.187の図 3.57をみる。
例えば{A, B, 1, 2、3}は状態集合であるが、このうち重要状態は{1, 2}のみ。どちらも基底ステップからなる。

* (1) - a -> (C)
* (2) - b -> (D)
* (3) - a -> (4)

また{C, E, 3}や{D, E, 3}も状態集合だが、このうち重要状態はそれぞれ{3}のみ。これもまた基底ステップからなる。

* (3) - a -> (4)

### 3.9.2

`(a|b)*a`を考える。構文木的にはこれは`(a|b)*`と`a`の連接である。

* nullable(n) = false. 末尾に必ずaが存在するので。
* first(n) = {1,2,3}. `(a|b)*`が
  * aかもしれない。その場合は1
  * bかもしれない。その場合は2
  * εかもしれない。その場合は3
* lastpos(n) = {3}. 常に末尾のaになるので。
* follwpos(p)はfollow集合のようなもの。

pは位置であり、位置とは構文木の葉であった。ここでの正規表現の構文木の葉はεもしくは文字である。follwpos(1)を考える。1というのは`(a|b)*a`の最初の`a`のことである。`follwpos(1)`というのはそのaのあとに出現することのある文字の位置である。
`a`の次は

* `(a|b)`の生成するa
* `(a|b)`の生成するb
* 最後の`a`

の可能性があるので、`follwpos(1)` = {1, 2, 3}

### 3.9.4

ある位置i1とi2があって、c1のあとにc2が出現できるパターンは2つある。

1. catのとき。 `c1 c2`だとする。lastpos(c1)の位置たちにとって、firstpos(c2)の全ての位置は自分のあとに出現する位置となる。
2. starのとき。`c1*`だとする。これは`c1 c1 ...`という繰り返しなので、lastpos(c1)のあとにfirstpos(c1)が出現する。

`((a|b)a)*`の例。 `((a|b)a) ((a|b)a) ((a|b)a) ...` なので、{3}のあとに{1, 2}が出現する。

P.191

> 根の firstpos に含まれるすべての位置を初期状態とする

P.190の図 3.59でいうと頂点の `{1, 2, 3} ◯ {6}` が根である。根のfirstposは初期状態を表す。

P.192のアルゴリズム。根のfirstposを初期状態とする。そこからはじめて

* 1つ状態を取り出す
* その状態の位置について対応する文字を考える
* それらの文字の位置についてfollowposを考えることで、いま取り出している状態の直後に来ることができる入力と、その入力に対応した次の状態が構成できる
* これを繰り返す

P.194 DFAの最小化





